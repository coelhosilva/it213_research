---
title: "EDA (Exploratory Data Analysis) - Modelo Gravitacional"
author: "Lucas Coelho"
date: "`r format(Sys.Date(), '%d/%m/%Y')`"
output:
  html_document:
    fig_caption: yes
    number_sections: yes
    theme: readable
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
  pdf_document:
    citation_package: biblatex
    fig_caption: yes
    number_sections: yes
fontsize: 12pt
header-includes:
- \setlength{\parindent}{1.5cm}
- \usepackage{setspace}\doublespacing
- \usepackage[brazilian]{babel}
- \usepackage{csquotes}
- \usepackage{float}
- \floatplacement{figure}{H}
classoption: a4paper
spacing: double
subtitle: Análise de dados exploratória e construção de um modelo inicial.
bibliography: refs.bib
---

```{r setwd, include=FALSE}

library(kableExtra)
library(cowplot)
library(readr)
library(dplyr)

```

\newpage
\tableofcontents 
\newpage
\listoffigures
\newpage

# Introdução
Este relatório descreve a condução de uma análise exploratória dos dados da matriz OD aérea bem como a construção de um modelo gravitacional que retrata o fluxo de passageiros.

# Análise de dados exploratória

O primeiro passo para a construção de um modelo é a condução de uma análise de dados exploratória a fim de se situar e conhecer melhor os dados. O objetivo aqui é visualizar as rotas aéreas dentro do estado de São Paulo bem como a construção de um modelo gravitacional para representar o fluxo de passageiros. Apenas as rotas do estado de São Paulo foram selecionadas visando a diminuição do custo computacional nesta fase de entendimento dos conceitos.

Boas referências:

- Dr Ds Idiots Guide to Spatial Interaction Modelling for Dummies - Part 1:
  - The Unconstrained (Total Constrained) Model by Adam Dennett available here https://rpubs.com/adam_dennett/257231
- Dr Ds Idiots Guide to Spatial Interaction Modelling for Dummies - Part 2: 
  - Constrained Models by Adam Dennett available here https://rpubs.com/adam_dennett/259068

O primeiro passo é a importação das bibliotecas a serem utilizadas:

```{r importing_lib, echo = TRUE, results = 'hide', warning=FALSE, message=FALSE}
library(geobr)
library(arrow)
library(ggplot2)
library(dplyr)
library(sf)
library(stplanr)
library(tidyr)
```

## Leitura dos dados

Em seguida, podemos fazer a importação dos dados. Os *data frames* de **matriz_od_aerea** e **cidades** foram previamente processada e salva em um arquivo .parquet para possibilitar uma leitura mais eficiente. O dataframe **cidades_geobr** consiste nos dados extraídos da biblioteca geobr, e contém os dados de mapeamento dos municípios.

```{r importing_data}
matriz_od_aerea <- read_parquet("./bd_tele_processed/matriz_od_aerea.gz.parquet") # matriz aérea processada em parquet
cidades <- read_parquet("./bd_tele_processed/cidades.gz.parquet") # cidades processada em parquet
cidades_geobr <- readRDS("./extra_data/cidades_geobr.rds") # Dados das cidades Brasileiras previamente capturados com o geobr (vide grab_cities_geobr.R)
```

## Tratamento dos dados

Primeiramente, os dados são filtrados a fim de exibir apenas as rotas interiores ao estado de São Paulo.

```{r treating_data_1}
# Filtrando os dados para apenas o estado de SP
matriz_od_aerea <- matriz_od_aerea %>% filter(UFUTPorigemunicipio=='SP',UFUTPdestinounicipio=="SP")
cidades <- cidades %>% filter(uf=="SP")
cidades_geobr <- cidades_geobr %>% filter(abbrev_state=="SP")
```

Em seguida, os dados são consolidados. O código de cidades utilizado nos dados de entrada é convertido no código de cidades do IBGE e presente no *data frame* de geometrias.

```{r treating_data_2}
# Unificando os dataframes de cidades, visando adicionar a geometria para o mapa
cidades$codigo <- as.numeric(as.character(cidades$codigo))
cidades_geobr$code_muni <- as.numeric(as.character(cidades_geobr$code_muni))
cidades_joined <-left_join(cidades, cidades_geobr, by = c("codigo" = "code_muni"))

matriz_od_aerea$code_origem <- cidades_joined$codigo[match(matriz_od_aerea$idmunicipioorigem, cidades_joined$idMunicipio)]
matriz_od_aerea$code_destino <- cidades_joined$codigo[match(matriz_od_aerea$idmunicipiodestino, cidades_joined$idMunicipio)]
```

Posteriormente, os dados são agrupados para pares únicos de origem-destino e quantidade total de viagens é obtida.

```{r treating_data_3, warning=FALSE, message=FALSE}
# calculo das viagens totais por origem-destino
matriz_od_aerea_summarized <- matriz_od_aerea %>%
  group_by(code_origem,code_destino) %>%
  summarize(
    viagensTotais = sum(quantidadeviagem)
  ) %>% 
  drop_na() #drop NA a ser corrigido. Por algum motivo, algumas viagens de MG estavam aparecendo (aeroporto de Uberlândia)
```

Para fins de simplificação e redução de custo computacional, apenas os trechos com mais de 150 viajantes são selecionados:

```{r treating_data_4}
# Filtrando para apenas as maiores viagens (mais de 150)
matriz_od_aerea_summarized <- matriz_od_aerea_summarized %>%
  filter(viagensTotais >= 150)
```

A malha de viagens é criada com a função od2line. Ela retorna um *data frame* que possui uma coluna com a geometria da rota, para o mapa.

```{r treating_data_5}
# Criação da rede de viagens com a função od2line
travel_network <- od2line(flow = matriz_od_aerea_summarized, zones = cidades_geobr)
head(travel_network)
```

## Gráficos

Por fim, a viagens aéreas dentro do estado de São Paulo são traçadas no mapa do estado. A função *read_municipality* da biblioteca **geobr** é utilizada para obter os limites do mapa de São Paulo.

```{r plotting_data_1, echo = TRUE, results = 'hide', warning=FALSE, message=FALSE}
all_muni_sp <- read_municipality(code_muni = "SP", year= 2019)
```
```{r plotting_data_2}
no_axis <- theme(axis.title=element_blank(),
                 axis.text=element_blank(),
                 axis.ticks=element_blank())

ggplot() +
  geom_sf(data=all_muni_sp, fill="#F5F5F5", color="#CCCCCC", size=.15, show.legend = FALSE) +
  geom_sf(data = travel_network$geometry, color=alpha("#8BBDD9", 0.4)) +
  labs(subtitle="Viagens no estado de São Paulo", size=8) +
  theme_minimal() +
  no_axis
```

# Construção do modelo gravitacional

O passo seguinte é a construção de um modelo gravitacional que estime as viagens entre duas localidades.

A equação clássica do modelo gravitacional é dada por:

$$T_{ij} = k V_i^\mu W_j^\alpha d_{ij}^{-\beta} $$

onde:
$T_{ij}$ é o fluxo entre a origem e o destino;
$V_i$ é a "emissibilidade" da origem - uma medida que indica o quanto as pessoas de lá saem. O que leva a ir;
$W_j$ é a "atratividade" do destino - uma medida que indica o quanto as pessoas chegam. O que leva a vir;
$d_{ij}$ é a resistência ao fluxo - como a distância;
k é a constante de proporcionalidade;
$\mu$, $\alpha$ e $\beta$ são os parâmetros do modelo.

Cenário de exemplo: viagens entre os bairros de uma cidade.

  - Exemplo de $V_i$: população. Pode-se argumentar que, quanto mais gente em um bairro, maior o fluxo de saída.
  - Exemplo de $W_j$: postos de trabalho. Pode-se argumentar que, quanto mais postos de trabalho em um bairro, mais pessoas fariam o traslado diariamente em direção ao bairro.

A fazer:

  - Pegar os dados de população do IBGE e consolidar com a matriz OD;
  - Selecionar possíveis candidatos para $V_i$. Renda? População?
  - Selecionar possíveis candidatos para $W_j$. PIB?
  - Avaliar dados socioeconômicos disponíveis em http://atlasbrasil.org.br/2013/pt/consulta/.

# Conclusão

Após a elaboração do estudo, incluir o texto com as conclusões e aprendizados iniciais.


\newpage
